--- a/drivers/char/vt.c	2009-08-17 13:20:28.857308622 +0800
+++ b/drivers/char/vt.c	2009-08-17 13:41:21.179059041 +0800
@@ -278,6 +278,19 @@
 	return p;
 }
 
+static inline unsigned short *screenpos_utf8(struct vc_data *vc, int offset, int viewed)
+{
+	unsigned short *p;
+
+	if (!viewed)
+		p = (unsigned short *)(vc->vc_origin + offset + vc->vc_screenbuf_size);
+	else if (!vc->vc_sw->con_screen_pos)
+		p = (unsigned short *)(vc->vc_visible_origin + offset + vc->vc_screenbuf_size);
+	else
+		p = vc->vc_sw->con_screen_pos(vc, -offset - 1);
+	return p;
+}
+
 static inline void scrolldelta(int lines)
 {
 	scrollback_delta += lines;
@@ -304,6 +317,11 @@
 	scr_memmovew(d, s, (b - t - nr) * vc->vc_size_row);
 	scr_memsetw(d + (b - t - nr) * vc->vc_cols, vc->vc_video_erase_char,
 		    vc->vc_size_row * nr);
+	d += (vc->vc_screenbuf_size >> 1);
+	s += (vc->vc_screenbuf_size >> 1);
+	scr_memmovew(d, s, (b - t - nr) * vc->vc_size_row);
+	scr_memsetw(d + (b - t - nr) * vc->vc_cols, 0,
+		    vc->vc_size_row * nr);
 }
 
 static void scrdown(struct vc_data *vc, unsigned int t, unsigned int b, int nr)
@@ -321,6 +339,9 @@
 	step = vc->vc_cols * nr;
 	scr_memmovew(s + step, s, (b - t - nr) * vc->vc_size_row);
 	scr_memsetw(s, vc->vc_video_erase_char, 2 * step);
+  	s += (vc->vc_screenbuf_size >> 1);
+  	scr_memmovew(s + step, s, (b - t - nr) * vc->vc_size_row);
+  	scr_memsetw(s, 0, 2 * step);
 }
 
 static void do_update_region(struct vc_data *vc, unsigned long start, int count)
@@ -488,6 +509,8 @@
 	static int old_offset = -1;
 	static unsigned short old;
 	static unsigned short oldx, oldy;
+	static unsigned short *p_ext = NULL;
+	static unsigned short old_ext = 0;
 
 	WARN_CONSOLE_UNLOCKED();
 
@@ -495,7 +518,7 @@
 	    old_offset < vc->vc_screenbuf_size) {
 		scr_writew(old, screenpos(vc, old_offset, 1));
 		if (DO_UPDATE(vc))
-			vc->vc_sw->con_putc(vc, old, oldy, oldx);
+			vc->vc_sw->con_putc(vc, (old_ext << 16)|old, oldy, oldx);
 	}
 
 	old_offset = offset;
@@ -505,13 +528,15 @@
 		unsigned short new;
 		unsigned short *p;
 		p = screenpos(vc, offset, 1);
+		p_ext = screenpos_utf8(vc, offset, 1);
 		old = scr_readw(p);
+		old_ext = scr_readw(p_ext);
 		new = old ^ vc->vc_complement_mask;
 		scr_writew(new, p);
 		if (DO_UPDATE(vc)) {
 			oldx = (offset >> 1) % vc->vc_cols;
 			oldy = (offset >> 1) / vc->vc_cols;
-			vc->vc_sw->con_putc(vc, new, oldy, oldx);
+			vc->vc_sw->con_putc(vc, (old_ext << 16)|new, oldy, oldx);
 		}
 	}
 
@@ -770,7 +795,7 @@
 	    visual_init(vc, currcons, 1);
 	    if (!*vc->vc_uni_pagedir_loc)
 		con_set_default_unimap(vc);
-	    vc->vc_screenbuf = kmalloc(vc->vc_screenbuf_size, GFP_KERNEL);
+	    vc->vc_screenbuf = kmalloc(vc->vc_screenbuf_size * 2, GFP_KERNEL);
 	    if (!vc->vc_screenbuf) {
 		kfree(vc);
 		vc_cons[currcons].d = NULL;
@@ -847,7 +872,7 @@
 	if (new_cols == vc->vc_cols && new_rows == vc->vc_rows)
 		return 0;
 
-	newscreen = kmalloc(new_screen_size, GFP_USER);
+	newscreen = kmalloc(new_screen_size * 2, GFP_USER);
 	if (!newscreen)
 		return -ENOMEM;
 
@@ -902,15 +927,24 @@
 	while (old_origin < end) {
 		scr_memcpyw((unsigned short *) new_origin,
 			    (unsigned short *) old_origin, rlth);
-		if (rrem)
+		scr_memcpyw((unsigned short *) new_origin + (new_screen_size >> 1),
+		            (unsigned short *) old_origin + (old_screen_size >> 1), rlth);
+		if (rrem){
+
 			scr_memsetw((void *)(new_origin + rlth),
 				    vc->vc_video_erase_char, rrem);
+		        scr_memsetw((void *)(new_origin + rlth + (new_screen_size)),
+		                    vc->vc_video_erase_char, rrem);
+		}
 		old_origin += old_row_size;
 		new_origin += new_row_size;
 	}
-	if (new_scr_end > new_origin)
+	if (new_scr_end > new_origin){
 		scr_memsetw((void *)new_origin, vc->vc_video_erase_char,
 			    new_scr_end - new_origin);
+	        scr_memsetw((void *)new_origin + (new_screen_size), vc->vc_video_erase_char,
+	                    new_scr_end - new_origin);
+	}
 	kfree(vc->vc_screenbuf);
 	vc->vc_screenbuf = newscreen;
 	vc->vc_screenbuf_size = new_screen_size;
@@ -2100,7 +2134,7 @@
 	}
 #endif
 
-	int c, tc, ok, n = 0, draw_x = -1;
+	int c, tc, tc_1 , ok, n = 0, draw_x = -1;
 	unsigned int currcons;
 	unsigned long draw_from = 0, draw_to = 0;
 	struct vc_data *vc;
@@ -2112,6 +2146,7 @@
 	u16 himask, charmask;
 	const unsigned char *orig_buf = NULL;
 	int orig_count;
+	int is_utf8 = 0;
 
 	if (in_interrupt())
 		return count;
@@ -2158,6 +2193,8 @@
 		rescan = 0;
 		inverse = 0;
 		width = 1;
+		vc->vc_utf = 1;
+		vc->vc_disp_ctrl = 0;
 
 		/* Do no translation at all in control states */
 		if (vc->vc_state != ESnormal) {
@@ -2199,6 +2236,7 @@
 			    vc->vc_utf_count = 0;
 			    c = 0xfffd;
 			} else if (c > 0x7f) {
+			    is_utf8 = 1;
 			    /* First byte of a multibyte sequence received */
 			    vc->vc_npar = 0;
 			    if ((c & 0xe0) == 0xc0) {
@@ -2224,8 +2262,9 @@
 				/* Still need some bytes */
 				continue;
 			    }
+			} else {
+				is_utf8 = 0;
 			}
-			/* Nothing to do if an ASCII byte was received */
 		    }
 		    /* End of UTF-8 decoding. */
 		    /* c is the received character, or U+FFFD for invalid sequences. */
@@ -2303,39 +2342,124 @@
 			}
 
 			while (1) {
-				if (vc->vc_need_wrap || vc->vc_decim)
-					FLUSH
-				if (vc->vc_need_wrap) {
-					cr(vc);
-					lf(vc);
-				}
-				if (vc->vc_decim)
-					insert_char(vc, 1);
-				scr_writew(himask ?
-					     ((vc_attr << 8) & ~himask) + ((tc & 0x100) ? himask : 0) + (tc & 0xff) :
-					     (vc_attr << 8) + tc,
-					   (u16 *) vc->vc_pos);
-				if (DO_UPDATE(vc) && draw_x < 0) {
-					draw_x = vc->vc_x;
-					draw_from = vc->vc_pos;
-				}
-				if (vc->vc_x == vc->vc_cols - 1) {
-					vc->vc_need_wrap = vc->vc_decawm;
-					draw_to = vc->vc_pos + 2;
-				} else {
-					vc->vc_x++;
-					draw_to = (vc->vc_pos += 2);
-				}
-
-				if (!--width) break;
+				if(is_utf8 == 0) {
+					if (vc->vc_need_wrap || vc->vc_decim)
+						FLUSH
+					if (vc->vc_need_wrap) {
+						cr(vc);
+						lf(vc);
+					}
+					if (vc->vc_decim)
+						insert_char(vc, 1);
+					scr_writew(himask ?
+						     ((vc_attr << 8) & ~himask) + ((tc & 0x100) ? himask : 0) + (tc & 0xff) :
+						     (vc_attr << 8) + tc,
+						   (u16 *) vc->vc_pos);
+					scr_writew(0, (u16 *) vc->vc_pos + (vc->vc_screenbuf_size >> 1));
+					if (DO_UPDATE(vc) && draw_x < 0) {
+						draw_x = vc->vc_x;
+						draw_from = vc->vc_pos;
+					}
+					if (vc->vc_x == vc->vc_cols - 1) {
+						vc->vc_need_wrap = vc->vc_decawm;
+						draw_to = vc->vc_pos + 2;
+					} else {
+						vc->vc_x++;
+						draw_to = (vc->vc_pos += 2);
+					}
+
+					if (!--width) break;
+
+					tc = conv_uni_to_pc(vc, ' '); /* A space is printed in the second column */
+					if (tc < 0) tc = ' ';
+
+					notify_write(vc, c);
+
+					if (inverse) {
+						FLUSH
+					}
 
-				tc = conv_uni_to_pc(vc, ' '); /* A space is printed in the second column */
-				if (tc < 0) tc = ' ';
-			}
-			notify_write(vc, c);
+				} else {
+					tc = 0xff;
+					tc_1 = 0xfe;
 
-			if (inverse) {
-				FLUSH
+					if (vc->vc_need_wrap || vc->vc_decim)
+						FLUSH
+					if (vc->vc_need_wrap) {
+						cr(vc);
+						lf(vc);
+					}
+
+					if (vc->vc_decim)
+						insert_char(vc, 1);
+					scr_writew(himask ?
+						     ((vc_attr << 8) & ~himask) + ((tc & 0x100) ? himask : 0) + (tc & 0xff) :
+						     (vc_attr << 8) + tc,
+						   (u16 *) vc->vc_pos);
+					scr_writew(c,
+						   (u16 *) vc->vc_pos + (vc->vc_screenbuf_size >> 1));
+					if (DO_UPDATE(vc) && draw_x < 0) {
+						draw_x = vc->vc_x;
+						draw_from = vc->vc_pos;
+					}
+					if (vc->vc_x == vc->vc_cols - 1) {
+						vc->vc_need_wrap = vc->vc_decawm;
+						draw_to = vc->vc_pos + 2;
+					} else {
+						vc->vc_x++;
+						draw_to = (vc->vc_pos += 2);
+					}
+
+					if (!--width) break;
+	
+					tc = conv_uni_to_pc(vc, ' '); /* A space is printed in the second column */
+					if (tc < 0) tc = ' ';
+
+					notify_write(vc, c);
+
+					if (inverse) {
+						FLUSH
+					}
+
+
+					if (vc->vc_need_wrap || vc->vc_decim)
+						FLUSH
+					if (vc->vc_need_wrap) {
+						cr(vc);
+						lf(vc);
+					}
+
+					if (vc->vc_decim)
+						insert_char(vc, 1);
+					scr_writew(himask ?
+						     ((vc_attr << 8) & ~himask) + ((tc_1 & 0x100) ? himask : 0) + (tc_1 & 0xff) :
+						     (vc_attr << 8) + tc_1,
+						   (u16 *) vc->vc_pos);
+					scr_writew(c,
+						   (u16 *) vc->vc_pos + (vc->vc_screenbuf_size >> 1));
+					if (DO_UPDATE(vc) && draw_x < 0) {
+						draw_x = vc->vc_x;
+						draw_from = vc->vc_pos;
+					}
+					if (vc->vc_x == vc->vc_cols - 1) {
+						vc->vc_need_wrap = vc->vc_decawm;
+						draw_to = vc->vc_pos + 2;
+					} else {
+						vc->vc_x++;
+						draw_to = (vc->vc_pos += 2);
+					}
+
+					if (!--width) break;
+	
+					tc = conv_uni_to_pc(vc, ' '); /* A space is printed in the second column */
+					if (tc < 0) tc = ' ';
+
+					notify_write(vc, c);
+
+					if (inverse) {
+						FLUSH
+					}
+				}
 			}
 
 			if (rescan) {
@@ -2875,7 +2999,7 @@
 		vc_cons[currcons].d = vc = kzalloc(sizeof(struct vc_data), GFP_NOWAIT);
 		INIT_WORK(&vc_cons[currcons].SAK_work, vc_SAK);
 		visual_init(vc, currcons, 1);
-		vc->vc_screenbuf = kzalloc(vc->vc_screenbuf_size, GFP_NOWAIT);
+		vc->vc_screenbuf = kzalloc(vc->vc_screenbuf_size * 2, GFP_NOWAIT);
 		vc_init(vc, vc->vc_rows, vc->vc_cols,
 			currcons || !vc->vc_sw->con_save_screen);
 	}
@@ -4025,9 +4149,15 @@
 	u16 w = scr_readw(screenpos(vc, offset, 1));
 	u16 c = w & 0xff;
 
-	if (w & vc->vc_hi_font_mask)
-		c |= 0x100;
-	return c;
+	u16 c_utf8 = scr_readw(screenpos_utf8(vc, offset, 1));
+
+	if ( (c == 0xff || c == 0xfe) && c_utf8 != 0){
+		return c_utf8;
+	}else{
+		if (w & vc->vc_hi_font_mask)
+			c |= 0x100;
+		return c;
+	}
 }
 EXPORT_SYMBOL_GPL(screen_glyph);
 
